\documentclass[10pt]{beamer}

\usetheme{metropolis}
\usepackage{appendixnumberbeamer,amsmath}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,calc,decorations.pathreplacing}

\DeclareMathOperator{\order}{Order}

\usepackage{libertine}
\usepackage[libertine]{newtxmath}
\usepackage{mathrsfs}
\include{../../letterfonts}
\DeclareMathOperator{\enc}{Enc}
\DeclareMathOperator{\res}{Res}
\DeclareMathOperator{\spec}{Spec}
\DeclareMathOperator{\cov}{Cov}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Rank}{rank}
\newcommand{\Tfae}{The following are equivalent:}
\newcommand{\tfae}{the following are equivalent:}
\newcommand{\sparsity}{\textit{sparsity}}
\DeclareMathOperator{\poly}{poly}
\newtheorem{claim}{Claim}
\title{Nisan's Pseudorandom Generator for \textsf{RL}}
\subtitle{$\textsf{BPL}\subseteq \textsf{SC}=\textsf{DTISP}(\poly(n),\log^2(n))$}
\date{December 2, 2025}
\author{Soham Chatterjee}
\institute{Pesudorandomness Course (CSS.413.1) Presentation, STCS}
\metroset{block=fill}
\pagestyle{empty}
\begin{document}

\maketitle

% \begin{frame}{Table of contents}
% 	\setbeamertemplate{section in toc}[sections numbered]
% 	\tableofcontents[hideallsubsections]
% \end{frame}
% \begin{frame}[c]{Complexity Classes}

% \centering
% \begin{tikzpicture}[
%     node distance=0.8cm and 2cm,
%     class/.style={font=\sffamily},
%     arrow/.style={-latex},
%     annotation/.style={font=\scriptsize, text=blue}
% ]
% \path[use as bounding box] (-3,-2) rectangle (3,-1);
% \node[class] (SC) at (0,0) {SC};
% \node[class, right=of SC] (NC) {NC};
% \node[class, left=of SC] (L2) {$\mathsf{L}^2$};

% % Now position other nodes relative to these
% \node[class, above=of NC] (P) {P};
% \node[class, above=of L2] (PolylogSpace) {PolylogSpace};
% \node[class, below=of SC] (BPL) {BPL};
% \node[class, below=of NC] (NL) {NL};
% \node[class, below=of L2] (L32) {$\mathsf{L}^{3/2}$};
% \node[class, below=of BPL] (RL) {RL};
% \node[class, below=of RL] (L) {L};

% % Draw arrows
% \draw[arrow] (L) -- (RL);
% \draw[arrow] (RL) -- (NL);
% \draw[arrow] (RL) -- (BPL);
% \draw[arrow] (RL) -- (L32);

% % From NL
% \draw[arrow] (NL) -- (NC);
% \draw[arrow] (NL) to[out=270,in=240,looseness=2.1] node[pos=0.7,annotation,above,sloped] {[Savitch]} (L2);

% % From BPL
% \draw[arrow] (BPL) -- (NC);
% \draw[arrow] (BPL) -- (L2);
% \draw[arrow] (BPL) -- node[midway,annotation,pos=0.6,above] {[Saks-Zhou]} (L32);

% % Left column
% \draw[arrow] (L32) -- (L2);
% \draw[arrow] (L2) -- (PolylogSpace);

% % From SC
% \draw[arrow] (SC) -- (PolylogSpace);
% \draw[arrow] (SC) -- (P);

% % From NC
% \draw[arrow] (NC) -- (P);
% % \draw[arrow, red] (BPL) -- node[midway,font=\scriptsize,right,pos=0.6,color=red] {Today} (SC);
% \draw<1>[arrow] (BPL) -- (SC);

% % Red "Today" edge: appears starting slide 2
% \draw<2->[arrow, red] (BPL) --
%   node[midway,font=\scriptsize,right,pos=0.6,color=red] {Today} (SC);
% \end{tikzpicture}
% \end{frame}
\begin{frame}{Pseudorandom Generator}
	\begin{definition}[Pseudorandom Generator]
		A map $\mcG:\{0,1\}^l\to \{0,1\}^n$, where $n\geq l$ is called a PRG for a class $\mcC$ with a parameter $\epsilon>0$ if for any $f\in \mcC$, $$\left|\underset{y\in\{0,1\}^n}{\bbP}[f(y)=1]-\underset{x\in\{0,1\}^l}{\bbP}[f(\mcG(x))=1]\right|\leq \epsilon$$
	\end{definition}
	\begin{itemize}
		\item Here $l$ is called the seed-length of the PRG.
		\item $n-l$ is called the stretch of the PRG.
		\item We call $\mcG$, $\epsilon$-fools $\mcC$.
		\item Typically, we want $n>> l$ and $\mcG$ to be efficiently computable.
	\end{itemize}
\end{frame}

\begin{frame}{Finite State Automata}
	Let $T$ be a \textsf{BPL} machine which uses $n^c$ random bits on inputs of length $n$ and runs in polynomial time and uses $S=O(\log n)$ space. \pause
	\begin{itemize}
		\item There are at most  $2^{O(S)}=\poly(n)$ configurations of $T$. \pause
		\item Each random bit is used to make a transition between two configurations. \pause
		\item The starting configuration is fixed for any input. \pause
		\item Input $x$ is accepted if $T$ reaches a state representing acceptance.
	\end{itemize} \pause

	Therefore the configuration graph of $T$ on input $x$ represents a finite state automata with $N=\poly(n)$ states.
\end{frame}

\begin{frame}[c]{Computational Tableau of \textsf{BPL} machine}
	\begin{figure}
		\centering
		\begin{tikzpicture}[
				box/.style={draw, minimum width=1.5cm, minimum height=6cm},
				brace/.style={decorate,decoration={brace,amplitude=5pt}},
				arrow/.style={-latex},
				txt/.style={font=\scriptsize}
			]

			% Main box
			\node[box] (B) at (0,0) {};

			% Horizontal slices
			\draw (B.north west)++(0,-1.5) -- ++(1.5,0);
			\draw (B.north west)++(0,-3) -- ++(1.5,0);
			\draw (B.north west)++(0,-4.5) -- ++(1.5,0);

			% Left input arrow
			\draw[arrow] (-2,3) -- ++(+1,0);
			\node[txt, anchor=east] at (-2,3) {$\text{Input: } x$};

			% Right braces + text
			\draw[brace] (B.north east)++(+0.05,0) -- ++(0,-1.5)
			node[midway,right=0.1cm,txt] {$k$ Random Bits};

			\draw[brace] (B.north east)++(+0.05,-1.5) -- ++(0,-1.5)
			node[midway,right=0.1cm,txt] {$k$ Random Bits};

			\draw[brace] (B.north east)++(+0.05,-4.5) -- ++(0,-1.5)
			node[midway,right=0.1cm,txt] {$k$ Random Bits};
			% Left Brace + text
			\draw[brace]
			(B.south west)++(-0.05,0) -- ++(0,6)
			node[midway, txt, left=0.1cm, align=right]{Time: $\poly(n)$\\ Random Bits: $n^{c}$};
			% Top Brace + text
			\draw[brace] (B.north west) ++(0,0.05) -- node[txt,midway,above=0.1cm] {Space: $ O(\log n)$}++(+1.5,0);
			% Bottom output arrow
			\draw[arrow] (B.south east) ++ (+1,0) node[txt,right=0.05cm,align=left] {Output: Accept/Reject} -- ++(-0.9,0);

			% Annotations
			\node[txt] at (0,-0.7) {$\vdots$};
		\end{tikzpicture}
		\caption{Computational Tableau of \textsf{BPL} machine $T$.}
	\end{figure}

\end{frame}

\begin{frame}{Dividing \textsf{BPL} Computation into Blocks}
	\begin{itemize}
		\item Let the \textsf{BPL} machine $T$ run in time $n^c$ using $n^{c'}$ random bits and $O(\log n)$ space on input $x$ of length $n$.
		\item Let $k<< n^{c}$ be a parameter to be fixed later.
		\item Divide the computation of $T$ into $t=n^c/k$ blocks, where each block uses $k$ random bits.
		\item We can treat each block as a separate \textsf{BPL} machine $T_i$ (in some sense) which takes input as the final configuration of $T_{i-1}$ and $k$ random bits.
	\end{itemize}
\end{frame}
\begin{frame}{FSA for Computation Blocks}
	\begin{itemize}
		\item We can think of $T$ as a finite state automata with $N$ states.
		\item Each state makes $2^k$ transitions where each transion corresponds to a choice of $k$ random bits. \pause
		\item Let $Q$ be this automata. For transition we write $Q(i;r)=j$ for any $r\in\{0,1\}^k$ if $Q$ goes from state $i$ to state $j$ when fed $r$. \pause
		\item Let $M$ be the matrix where $M[i,j]=\underset{r\in\{0,1\}^k}{\bbP}[Q(i;x)=j]$\pause
	\end{itemize}
	$$\underset{r\in \{0,1\}^{k\times t}}{\bbP}[T(x,r)=\text{Acc}]=\sum_{j:\text{Accepting state}}M^t[1,j]$$

	\textbf{Goal:} Approximate $M^t$ using PRG.
\end{frame}
\begin{frame}{Approximate Automata Matrix}
	Suppose we have a pseudorandom generator $\mcG:\{0,1\}^k\to \{0,1\}^{k\cdot t}$. Let $Q$ be a finite state automata with $N$ staes and its matrix be $M$ as defined above.
	\begin{itemize}
		\item From definition of $M$, $M^t[i,j]=\underset{r_1,\dots, r_t\in\{0,1\}^k}{\bbP}[Q(i;r_1\dots ;r_t)=j]$
		\item Using $\mcG$, let $M_{\mcG}[i,j]=\underset{r\in\{0,1\}^k}{\bbP}[Q(i;\mcG(r))=j]$
		\item Want to construct $\mcG$ such that $$\|M^t-M_{\mcG}\|<\epsilon$$ for small $\epsilon$ with high probability.
	\end{itemize}
\end{frame}
\begin{frame}{Matrix Norm}
	For any vector $v\in \bbR^N$, define $\|v\|=\sum_{i\in [N]}|v(i)|$. Then for any matrix $M\in \bbR^{N\times N}$ define $$\|M\|=\sup\limits_{0\neq v\in\bbR^N}\frac{\|Mv\|}{\|v\|}$$\pause

	\textbf{Properties:}\begin{itemize}
		\item $\|M\|=\max\limits_{i\in [N]}\sum_{j\in [N]}|M[i,j]|$
		\item $\|M+N\|\leq \|M\|+\|N\|$
		\item $\|MN\|\leq \|M\|\cdot \|N\|$
	\end{itemize}
\end{frame}
\begin{frame}{Universal Hash Family}
	\begin{definition}[Universal Hash Family (Carter-Wegman)]
		$\mcH=\{h:\{0,1\}^k\to\{0,1\}^m\}$ is a \textit{universal hash family} if for any $x_1\neq x_2\in\{0,1\}^k$ and $y_1,y_2\in\{0,1\}^m$,\begin{itemize}
			\item $\underset{h \in \mathcal{H}}{\bbP}[\,h(x_1) = y_1\,] \;=\; \frac{1}{2^m}$
			\item $\underset{h \in \mathcal{H}}{\bbP}[\,h(x_1)=y_1 \;\wedge\; h(x_2)=y_2\,]
				      \;=\; \frac{1}{2^{2m}}$
		\end{itemize}
	\end{definition}\pause

	\vfill

	\begin{itemize}
		\item For our purpose, we have $k=m$. \pause
		\item We can construct such a family with $|\mcH|=2^{O(k)}$ where $$\mcH=\{a\cdot x+ b\mid a,b\in\{0,1\}^k\}$$ over $GF(2^k)$.
	\end{itemize}
\end{frame}

\begin{frame}{Property of Universal Hash Family}
	\begin{definition}[$(\epsilon,A,B)$-good hash function]
		Let $A\subseteq \{0,1\}^k$, $B\subseteq \{0,1\}^m$, $\epsilon>0$, $h:\{0,1\}^k\to\{0,1\}^m$ is said to be \textit{$(\epsilon,A,B)$-good} if
		$$\left|\underset{x\in\{0,1\}^k}{\bbP}[x\in A\wedge h(x)\in B]-\alpha\cdot \beta\right|\leq \epsilon$$
		where $\alpha=\frac{|A|}{2^k}$ and $\beta=\frac{|B|}{2^m}$.
	\end{definition}\pause

	\vfill

	\begin{lemma}
		If $\mcH$ is a universal hash family, then for any $A\subseteq \{0,1\}^k$, $B\subseteq \{0,1\}^m$, $\epsilon>0$, $$\underset{h\in\mcH}{\bbP}[h\text{ is not $(\epsilon,A,B)$-good}]\leq \frac{\alpha\cdot\beta}{2^k\epsilon^2}$$
	\end{lemma}\pause

	For $k=m$, by union bound an uniformly random $h$ is $\left(\frac{\epsilon}{k^2}, A,B\right)$-good for all $A,B$.
\end{frame}
\begin{frame}{Nisan's Generator}
	Let $\mcH$ be an universal hash family from $\{0,1\}^k$ to $\{0,1\}^k$. For any integer $m\geq 0$ define the function $\mcG_m\colon\{0,1\}^k\times \mcH^{m}\to \{0,1\}^{k\cdot 2^m}$ recursively as follows:\pause
	\begin{itemize}
		\item $\mcG_0(x)=x$
		\item $\mcG_m(x,h_1,\dots, h_m)=(\mcG_{m-1}(x,h_1,\dots ,h_{m-1}), \mcG_{m-1}(h_m(x),h_1,\dots, h_{m-1}))$
	\end{itemize}\pause

	For example: $$\mcG_1(x,h)=(x,h(x)),\quad \mcG_2(x,h_1,h_2)=(x,h_1(x), h_2(x), h_1\cdot h_2(x))$$ \pause
	$$\mcG_3(x,h_1,h_2,h_3)=(x,h_1(x), h_2(x), h_1\cdot h_2(x), h_3(x), h_1\cdot h_3(x), h_2\cdot h_3(x), h_1\cdot h_2\cdot h_3(x))$$\pause

	\begin{itemize}
		\item We want $k\cdot 2^m=n^c\implies m=\log t$.
		\item This gives a stretch of $k\cdot (t-1)$ bits.
	\end{itemize}
\end{frame}
\begin{frame}{Proof Flow}
	Let $h_1,\dots, h_s$ be some fixed hash functions from $\mcH$.  Define the matrix $$M_{h_1,\dots, h_s}[i,j]=\underset{x\in\{0,1\}^k}{\bbP}[Q(i;\mcG_s(x,h_1,\dots, h_s))=j]$$
	\vspace{-0.5cm}

	\begin{itemize}
		\item Using $h_1,\dots, h_s$ we had $2^s$ many transitions in $Q$. So we should compare $M_{h_1,\dots, h_s}$ with $M^{2^s}$.
	\end{itemize}

	\textbf{Goal:} For `good' choice of $h_1,\dots, h_m$, $\|M^{2^m}-M_{h_1,\dots, h_m}\|<\epsilon$

	\textbf{Approach:} 

		\textbf{Step 1:} Suppose we have $h_1,\dots, h_{s-1}$. We will find $h_s\in \mcH$ such that for all $i,j\in [N]$, $$\left\|M^2_{h_1,\dots, h_{s-1}}-M_{h_1,\dots, h_s}\right\|\leq \delta$$
		\textbf{Step 2:} Using above property show for all $s\in[m]$, $$\left\|M_{h_1,\dots, h_s}-M^{2^s}\right\|\leq (2^s-1)\delta$$
\end{frame}
\begin{frame}{Find good $h_s$ from $h_1,\dots, h_{s-1}$}
	Suppose we have $h_1,\dots, h_{s-1}\in \mcH$ such that, $$ \left\|M_{h_1,\dots, h_{ls-1}}-M^{2^{s-1}}\right\|\leq (2^{s-1}-1)\delta$$If we can find $h_s$ such that $\|M^2_{h_1,\dots, h_{s-1}}-M_{h_1,\dots, h_s}\|\leq \delta$ then we are done. 

	\textbf{Algorithm:} Go over all $h\in \mcH$ and all $i,j\in [N]$:

	\textbf{Step 1:}  Compute \begin{itemize}
		\item $p_1=M_{h_1,\dots, h_{s-1}, h}[i,j]$
		\item $p_{2}=\sum_{l\in [N]}M_{h_1,\dots, h_{s-1}}[i,l]\cdot M_{h_1,\dots, h_{s-1}}[l,j]$
	\end{itemize}
	\textbf{Step 2:} Check if $|p_1-p_2|>\frac{\delta}{N}$ go to next $h$ else return $h$. 

	% To compute $M_{h_1,\dots, h_{s}}[i,j]$, go over all $r\in\{0,1\}^k$ and count how many $r$ gives, $Q(i;\mcG_s(r,h_1,\dots, h_s))=j$. then return $count/2^k$.

\end{frame}
\begin{frame}{Algorithm returns \emph{good} $h_s$}
\begin{claim}
If $h_s$ is returned by the above algorithm, then $$\left\|M_{h_1,\dots, h_s}-M^{2^s}\right\|\leq (2^s-1)\delta$$\pause
\end{claim}
	We have $\|M^2_{h_1,\dots, h_{s-1}}-M_{h_1,\dots, h_s}\|\leq \delta$. \pause
	$$
		\|M_{h_1,\dots, h_s}-M^{2^s}\|  \leq \|M_{h_1,\dots, h_s}-M_{h_1,\dots, h_{s-1}}^2\|+\|M_{h_1,\dots, h_{s-1}}^2-M^{2^s}\|
		$$\pause
\begin{align*}
	\|M_{h_1,\dots, h_{s-1}}^2-M^{2^s}\|
		&\leq \|M_{h_1,\dots, h_{s-1}}\|\cdot \|M_{h_1,\dots, h_{s-1}}-M^{2^{s-1}}\| \\ 
		&\qquad \qquad\quad+ \|M_{h_1,\dots, h_{s-1}}-M^{2^{s-1}}\|\cdot \|M^{2^{s-1}}\|\\
	\uncover<5->{%
		&\le 1\cdot (2^{s-1}-1)\delta
		  +(2^{s-1}-1)\delta\cdot 1
		  =(2^s-2)\delta
	}
\end{align*}


\end{frame}
\begin{frame}[standout]
	Thank You
\end{frame}
\end{document}
