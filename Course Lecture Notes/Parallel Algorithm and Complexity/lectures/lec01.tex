\section{Addition of Two Numbers in Binary}
\textbf{Problem:} $\textsc{ADD}_{2n}$\\
\textbf{Input:} Two $n$ bit numbers $a=a_{n-1}\cdots a_1a_0$ and $b=b_{n-1}\cdots b_1b_0$\\
\textbf{Output:} $s=s_n\cdots s_1s_0$ where $s\overset{\text{def}}{=}a+b$\\

\subsection{Sequential (Ripple Carry)} For sum of any position $i$ the two bits $a_i$, $b_i$ and the carry generated by the previous position $c_{i-1}$ is added. For the initial position we can set $c_0=0$. If we add two bits at most 2 bits is created. The right bit is called the sum bit and the left bit is the carry bit. $a_i+b_i+c_{i-1}=c_is_i$. Then $$s_i=a_i\oplus b_i \oplus c_{i-1}\text{ and } c_i=(a_{i}\wedge b_{i})\vee (b_{i} \wedge c_{i-1}) \vee (c_{i-1} \wedge a_i)$$\\
\textbf{Time Complexity:} This algorithm takes $O(n)$ time complexity

\subsection{Parallel (Carry Look Ahead Adder)}
There is a carry that ripples into position $i$ if and only if there is some position $j < i$ to the right where this carry is generated, and all positions in between propagate this carry. A carry is generated at position $i$ if and only if both input bits $a_i$ and $b_i$ are on, and a carry is eliminated at position $i$, if and only if both input bits $a_i$ and $b_i$ are off. This leads to the following definitions: 

For $0 \leq  i < n$, let\begin{align*}
	g_i=a_i\wedge b_i &  &  & \text{position $i$ generates a carry}                        \\
	p_i=a_i\vee b_i   &  &  & \text{position $i$ propagates a carry that ripples int o it}
\end{align*}
So we can set for $1\leq i \leq n$ $$c_i=\bigvee_{j=0}^{i-1}\lt( g_j\wedge \bigwedge_{k=j+1}^{i-1} \rt)$$ Now the sumbits are calculated as before $s_i=a_i\oplus b_i \oplus c_{i-1}$ for $0\leq i\leq n-1$ and $s_n=c_n$\\
\textbf{Time Complexity:} This algorithm takes $O(1)$ time complexity

\begin{definition}[$\textsc{AC}^0$]
	The class of circuits consists of the gates $(\vee_n,\wedge_n,\neg_1)$ (The subscript $n$ or $1$ denotes the fanin) of polynomial size and depth $O(1)=O(\log^0 n)$ 
\end{definition}



\section{Iterated Addition}
\textbf{Problem:} $\textsc{IterADD}_{k,m}$\\
\textbf{Input:} $k$ many $m$-bit numbers $a_1,\dots,a_k$\\
\textbf{Output:} The sum of the input numbers\\

\begin{definition}[Length Respecting]
Let $f:\{0,1\}^* \to \{0,1\}^*$ . $f$ is length respecting if for all $x,y\in \{0,1\}^*$ $|f(x)|=|f(y)|$
\end{definition}

\begin{definition}[Constant Depth Reduction]
	let  $f,g:\{0,1\}^*\to \{0,1\}^*$  be length respecting. Then $f$ is constant depth reducible to $g$ or $f\leq_{cd} g$  if there is an unbounded fanin constant depth circuit computing $f$ from the bits of $g$.
\end{definition}
\begin{theorem}
	$\textsc{ADD}_{2n}=\textsc{IterADD}_{2,n}\in \textsc{AC}^0$
\end{theorem}
\subsection{Iterated Addition of Logarithmically many $n$-bit numbers}
\begin{theorem}\label{addlognloglogn}
	$\textsc{IterADD}_{\log n,n}\leq_{cd} \textsc{IterADD}_{\log\log n,O(n)}$
\end{theorem}
\begin{proof}
	We will denote $\log n=l$. We are given $l$ many $n$-bit numbers $a_1,\dots,a_l$, where $bin(a_i)=a_{i,n-1}\dots a_{i,1}a_{i,0}$. We add all the $l$ many bits at $i$th position of all numbers. we know if we add $m$ bits then we have at most $\log m$ many bits. So adding the $l$ many bits will take $\log l=\log\log n$ many bits. $s_{k}=\sum\limits_{i=1}^l a_{i,k}$. Hence $bin(s_k)= s_{k,\log l-1}\dots s_{k,1}s_{k,0}$. Hence $\sum\limits_{i=1}^{l}a_{i,k}=\sum\limits_{j=0}^{\log l-1}s_{k,j}2^j$
\begin{align*}
	\sum\limits_{i=1}^{l}a_{i}&=\sum\limits_{i=1}^{l}\sum\limits_{k=0}^{n-1}a_{i,k}2^k=\sum\limits_{k=0}^{n-1}\sum\limits_{i=1}^{l}a_{k,k}2^k= \sum\limits_{k=0}^{n-1} \sum\limits_{j=0}^{\log\log n-1}s_{k,j}2^j\cdot 2^k= \sum\limits_{j=0}^{\log\log n-1}\sum\limits_{k=0}^{n-1}s_{k,j}2^{j+k}
\end{align*}So this is converted to addition of $\log\log n$ many numbers of at most $n+\log\log n=O(n)$ many bits. 
\end{proof}
Recursing like this we have $\textsc{IterADD}_{\log\log n,n}\leq _{cd} \textsc{IterADD}_{2,O(n)}$. Hence
\begin{theorem}\label{addlognac0}
$\textsc{IterADD}_{\log n,n}\leq _{cd} \textsc{IterADD}_{2,O(n)}$ and therefore $\textsc{IterADD}_{\log n,n}\in \textsc{AC}^0$
\end{theorem}

\begin{remark}
	Apart from this $O(\log^*n)$ method to prove $\textsc{IterADD}_{\log n,n}\in \textsc{AC}^0$ there is also another method in \href{https://www.iarcs.org.in/activities/elnotes/pdf/cc.pdf}{Vinay Kumar's Lecture Notes}
\end{remark}
\subsection{Iterated Addition of $n$ many $n$-bit numbers}
We know $\textsc{IterADD}_{n,n}\leq _{cd} \textsc{IterADD}_{n,1}$ but we dont know anything about $\textsc{IterADD}_{n,n}\leq_{cd} \textsc{IterADD}_{\log n,n}$.  If that happens it will put $\textsc{IterADD}_{n,n}$ to $\textsc{AC}^0$.

\begin{remark}
	$\textsc{IterADD}_{n,1}$ is also known as $\textsc{BCOUNT}_n$.
\end{remark}
\begin{theorem}\label{addnnbcrel}
	$\textsc{IterADD}_{n,n}\leq_{cd} \textsc{IterADD}_{n,1}$
\end{theorem}

\begin{proof}
Let we given $n$ many $n$-bit numbers $a_1,\dots,a_n$, where $bin(a_i)=a_{i,n-1}\dots a_{i,1}a_{i,0}$. First we compute $s_{k}=\sum\limits_{i=1}^n a_{i,k}$ using $\textsc{BCOUNT}_n$ for all $0\leq k\leq n$. Now it becomes addition of $\log n$ many $O(n)$ bit numbers which we already know is in $\textsc{AC}^0$ by \hyperref[addlognac0]{Theorem \ref{addlognac0}}. Hence $\textsc{IterADD}_{n,n}\leq_{cd} \textsc{BCOUNT}_n$
\end{proof}


\section{$\textsc{IterADD}_{n,n}\equiv \textsc{BCOUNT}_n\equiv \textsc{Threshold}_{n,m} \equiv \textsc{Majority}_n\equiv \textsc{MULT}_{n}\equiv \textsc{SORT}_{n,n}$}
\textbf{Problem:} $\textsc{MULT}$\\
\textbf{Input:} 2 $n$-bit numbers $a=a_0,\dots,a_{n-1}$, $b=b_0,\dots,b_{n-1}$\\
\textbf{Output:} $c=a\cdot b$\\
\begin{theorem}\label{multaddrel}
	$\textsc{MULT}_{n,n}\leq \textsc{IterADD}_{n,n}$
\end{theorem}
\begin{proof}
	Given $a,b$ where $bin(a)=a_{n-1}\cdots a_1a_0$ and $bin(b)=b_{n-1}\cdots b_1b_0$ then obviously $$a\cdot b=\sum\limits_{i=0}^{n-1}a\cdot b_i\cdot 2^i$$Define for all $0\leq i\leq n-1$ $$c_i=\begin{cases}
		0^{n-i-1}a_{n-1}\cdots a_1a_0 0^u & \text{when $b_i=1$}\\
		0^{2n-1} & \text{otherwise}
	\end{cases}$$i.e. $c_i=a\cdot 2^i$ if $b_i=1$. Each $c_i$ is of $2n-1=O(n) $ many bits long. Hence we have $a\cdot b=\sum\limits_{i=0}^{n-1} c_i$. Hence now we can use the $\textsc{IterADD}_{n,n}$ gate to add the $n$ many $O(n)$ many bits to find the multiplication of $a$ and $b$. Therefore $\textsc{MULT}_n\leq \textsc{IterADD}_{n,n}$.
\end{proof}\parinf

\textbf{Problem:} $\textsc{Majority}_n$\\
\textbf{Input:} $n$ bits $a_{n-1},\dots, a_0$\\
\textbf{Output:} Find if at least half of the bits are 1\parinn

\begin{theorem}\label{majmultrel}
	$\textsc{Majority}\leq \textsc{MULT}$
\end{theorem}
\begin{proof}
	Given $a_0,\dots,a_{n-1}$. Take the number $a$ such that $bin(a)=a_{n-1}\cdots a_1a_0$. Denote $l\coloneqq \log n$. Define $$A=\sum\limits_{i=0}^{n-1}a_i\cdot 2^{li}\text{ and }B=\sum\limits_{i=0}^{n-1}2^{li}$$where both $A$ and $B$ consists of $n$ blocks of length $l$. We took $l$ length block because summation of $n$ bits takes at most $l$ bits. Let $C=A\cdot B$ We represent $C$ in binary as $l$ length blocks where  $C=\sum\limits_{i=0}^{2n-1}c_i\cdot 2^{li}$. Each $c_i$ is a $l$ length block. Then the middle block $c_{n-1}$ have exactly the computation of the sum of the $a_i$. Therefore $c_{n-1}=\sum\limits_{i=0}^{n-1}a_i$.
	
	$A$ and $B$ are constructed in constant depth and fed into $\textsc{MULT}$ gates yielding $C$. Now we have to compare $c_{n-1}$ with $\frac{n}{2}$ which can be done in constant depth.
\end{proof}\parinf

\textbf{Problem:} $\textsc{ExactThreshold}_{n,m}$\\
\textbf{Input:} $n$ bits $a_{n-1},\dots, a_0$\\
\textbf{Output:} Find if $\sum\limits_{i=0}^{n-1}= m$\\[2mm]
We have another similar problem but we have greater than instead of equality.\\[2mm]
\textbf{Problem:} $\textsc{Threshold}_{n,m}$\\
\textbf{Input:} $n$ bits $a_{n-1},\dots, a_0$\\
\textbf{Output:} Find if $\sum\limits_{i=0}^{n-1}\geq m$\parinn

\begin{theorem}\label{bcthmajrel}
	$\textsc{BCOUNT}\leq \textsc{ExactThreshold}\leq \textsc{Threshold}\leq \textsc{Majority}$
\end{theorem}

\begin{proof}
	{$\textsc{BCOUNT}\leq \textsc{ExactThreshold}$}: Let $\sum\limits_{i=0}^{n-1}a_i=\sum\limits_{i=0}^{\log n}s_i\cdot 2^i$. Denote $l\coloneqq \log n$. Let for all $0\leq j\leq l$, $R_j$ denote the set of all numbers $r\in \{0,\dots,n\}$ whose $j$-th bit is 1 in its binary representation . Then we can say $$s_j=\bigvee_{r\in R_j}\lt\llbracket \sum\limits_{i=0}^{n-1}a_i=r\rt\rrbracket$$Now $R_j$ don't depend on the input but only on the input $n$ so it can be hardwired this into the circuit. Thus we have a circuit for $\textsc{BCOUNT}$ which uses $\textsc{ExactThreshold}$.
	
	{$\textsc{ExactThreshold}\leq \textsc{Threshold}$}: We know for any $r$ and a variable $x$ certainly $$\llbracket x=r\rrbracket= \llbracket x\geq r\rrbracket \wedge  \llbracket x< r+1\rrbracket$$With this we have a constant depth circuit for $\textsc{ExactThreshold}$ using the $\textsc{Threshold}$ gates.
	
	{$\textsc{Threshold}\leq \textsc{Majority}$}: We are given $a_0,\dots,a_{n-1}$. Let we want to find $\sum\limits_{i=0}^{n-1}\geq m$ then we have this following relations $$\sum\limits_{i=0}^{n-1}a_i\geq m\iff \begin{cases}
		\textsc{Maj}_{2n-2m}\lt(a_0,\dots, a_n,\underbrace{1,\dots,1}_{n-2m}\rt) & \text{wher $m<\frac{n}{2}$}\\
		\textsc{Maj}_{2m}\lt(a_0,\dots, a_n,\underbrace{0,\dots,0}_{n-2m}\rt) & \text{wher $m\geq\frac{n}{2}$}
	\end{cases}$$
	This $\textsc{Maj}_{2n-2m}$ and $\textsc{Maj}_{2m}$ can be constructed in constant depth.
\end{proof}

\begin{remark}
	Hence using the theorems above we have the final relation $$\textsc{Majority}\leq \textsc{MULT}\leq \textsc{IterADD}_{n,n}\leq \textsc{BCOUNT}\leq \textsc{ExactThreshold}\leq \textsc{Threshold}\leq \textsc{Majority}$$ which gives the following corollary
\end{remark}

\begin{corollary}\label{itaddbcmajmultthreq}
	$\textsc{IterADD}_{n,n}\equiv \textsc{BCOUNT}\equiv \textsc{Threshold} \equiv \textsc{Majority} \equiv MULT$
\end{corollary}


\begin{definition}[$\textsc{TC}^0$]
	Constant depth polynomial size unbounded fanin circuit family using the gates $\wedge, \vee, \neg,\textsc{Maj}$.\\
	Alternating Definition: Constant depth polynomial size unbounded fanin circuit family using the gates $ \neg,\textsc{Maj}$.
\end{definition}
\begin{theorem}
	Both the definitions of $\textsc{TC}^0$ are equivalent.
\end{theorem}

\begin{theorem}
	$\textsc{IterADD}_{n,n}$, $\textsc{BCOUNT}$, $\textsc{MULT}\in \textsc{TC}^0$
\end{theorem}
\begin{proof}
	By \hyperref[itaddbcmajmultthreq]{Corollary \ref{itaddbcmajmultthreq}} we have the result.
\end{proof}
